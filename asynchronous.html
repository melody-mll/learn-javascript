<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>异步编程</title>
</head>
<body>
    <script>
        //异步编程
        //同步与异步
        //简单的同步与异步
        let x=2;
        x=x+8;

        let i=2;
        setTimeout(()=>{return i=i+9,console.log(i)},2000);

        function double(value) {
        setTimeout(() => setTimeout(console.log, 0, value * 2), 1000);
        }
        double(3);

        //异步返回值
        //给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码
        function asyndouble(value,callback){
            setTimeout(()=>callback(value),3000);
        }
        asyndouble(3,(value)=>{console.log(`the value is ${value*2}`)},3000);

        //异步操作的成功失败处理
        function suc(value,success,failure){
            setTimeout(
                ()=>{
                    try{
                    if(typeof value !=='number'){
                        throw('must provide number type')
                    }
                    success(value*2);
                }catch(e)
                {
                    failure(e);
                }
                }
                ,1000)
        }
        let successcallback=function(value){
            console.log(`the success value is ${value*2}` )
        }
        let failurecallback=function(value){
            console.log(`the error is ${value}`)
        }
        suc(1,successcallback,failurecallback);// the success value is 2
        suc('a',successcallback,failurecallback);// the error is must provide number type

        const successcallbacks=(x)=>{
            double(x,(y)=>{console.log(`success ${y}`)})           
        }
        suc(1,successcallbacks,failurecallback);

        //期约
        let p=new Promise(()=>{});
        setTimeout(console.log,0,p);//Promise <pending>
        //把一个期约实例传给控制台时，表示当前是pending状态，
        //期约有三种状态，fulfiled,rejected状态，状态是不可逆的，而这两种状态则不可更改
        let p1=new Promise((resolve,reject)=>resolve());
        setTimeout(console.log,0,p1);//<fulfilled>
        let p2=new Promise((resolve,reject)=>reject());
        setTimeout(console.log,0,p2);//<rejected>

         //期约并非一开始处于pending状态
         let p5=new Promise((resolve,reject)=>resolve());//此时处于fulfilled状态
         let p6=Promise.resolve()//这两种方式是等同的   

        new Promise(()=>{setTimeout(console.log,0,"first")});
        setTimeout(console.log,0,"second");
        
        let ps=new Promise((resolve,reject)=>setTimeout(reject,1000));
        setTimeout(console.log,0,ps);//此时不会报出错误，因为setTimeout推迟了切换状态，此时ps的状态还没有改变
        //只要resolve或者reject中一个被调用，则不会改变状态，
        let p3=new Promise((resolve,reject)=>{
            reject();
            resolve();
        })
        setTimeout(console.log,0,p3)

        //Promise.resolve() 可以说是一个幂等方法
        let p7=new Promise(()=>{});
        setTimeout(console.log,0,p7);
        setTimeout(console.log,0,Promise.resolve(p7));
        console.log(p7===Promise.resolve(p7));//true

        let p8=new Promise((resolve,reject)=>reject(7));
        setTimeout(console.log,0,p8);
        p.then(null, (e) => setTimeout(console.log, 0, e));

        //同步/异步执行的二元性
        //错误抛出
        try{
            throw("error");
        }catch(e){
            console.log(e);//erroe抛出错误并且接受到错误
        };
        try{
            Promise.reject(new Error("Error"));//抛出错误，但是没有接受到
        }catch(e){
            console.log(e);//uncaught (in promise) 
        }


        //期约的实例方法
        //实现Thenable接口
        //在这个异步结构中，任何对象都有一个then()方法，这个方法实现了Thenable接口
        class Thenable{
            then(){}
        }
        let then=new Thenable();
        console.log(then);

        //Promise.prototype.then()
        //这个then()方法最多接受两个参数,onResolve处理程序,onReject处理程序,分别在期约进入“兑现”和“拒绝”时实行
        function onResolves(id){
            setTimeout(console.log,0,id,"onresolve");//s1 onresolve
        }
        function onReject(id){
            setTimeout(console.log,0,id,"onreject");//s2 onreject
        }
        let s1=new Promise((resolve,reject)=>setTimeout(resolve,2000));
        let s2=new Promise((resolve,reject)=>setTimeout(reject,2000));
        s1.then(()=>onResolves("s1"),
        ()=>onReject("s1"));//因为期约状态是互斥的，所以这两个函数只有一个会执行，/
        s2.then(()=>onResolve("s1"),//如果不需要传两个参数，则可将不传的参数转为undefined
        ()=>onReject("s2"));

    </script>
</body>
</html>