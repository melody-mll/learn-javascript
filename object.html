<!DOCTYPE html>
<html>
<head>
	<title>object</title>
</head>
<body>
	<div>object</div>
	<script type="text/javascript">
		//可通过实例化的方法创建对象
		let person=new Object();
		person.name="mll";
		person.age=22;
		person.func=function(){
			console.log(this.name);
		}
		person.func();
		console.log(person);
		//
		let person1={
			name:'mll',
			age:22,
			func(){
				console.log(this.name);
			}
		}
		person1.func();
		//数据属性
		//[Configurable]表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性
		//[Enumerable]表示属性是否能够通过for-in循环返回
		//[Writable]表示属性的值是否可修改,一般默认是true
		//[Value]表示属性实际的值
		//要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象
		let person2={};
		Object.defineProperty(person2,"name",{
			Writable:false,//设置为不可更改模式
			value:'mll'
		})
		console.log(person2);//mll
		person2.name="zyl";
		console.log(person2.name);//mll

		//访问器属性
		//[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性
		//[Enumerable]表示属性是否能够通过for-in循环返回
		//[[Get]]：获取函数，在读取属性时调用。默认值为 undefined。
		//[[Set]]：设置函数，在写入属性时调用。默认值为 undefined。
		let books = { 
				 year_: 2017, 
				 edition: 1
			};

        //属性 year 被定义为一个访问器属性  
		Object.defineProperty(books,"year",{
			get(){
				return this.year_;
			},
			set(newValue){
				if(newValue>2017){
					this.year_=newValue;
					this.edition+=newValue-2017;
				}

			}
		});
		books.year=2018;
		console.log(books.edition);


		//定义多个属性
		let book={};
		Object.defineProperties(book,{
			year_:{
				value:2017
			},
			edition:{
				value:1
			},
			year:{//访问器属性
				get(){
					return this.year_;
				},
				set(newValue){
					if(newValue>2017){
						this.year_=newValue;
                        this.edition+=newValue-2017;
					}
				}
			}
		});
		book.year=2018;
		console.log(book.edition);

		//读取属性的特性
		//使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符
		//接受两个参数：属性所在的对象和要取得其描述符的属性名。
		let descriptors = Object.getOwnPropertyDescriptor(book, "year_");
		//对于数据属性， 
		console.log(descriptors.value); // 2017 
		console.log(descriptors.configurable); // false 
		console.log(typeof descriptors.get); // "undefined" 
		let descriptor = Object.getOwnPropertyDescriptor(book, "year"); 
		console.log(descriptor.value); // undefined 
		console.log(descriptor.enumerable); // false 
		console.log(typeof descriptor.get); // "function"，get是一个获取函数的指针


		//Object.getOwnPropertyDescriptors()静态方法，这个方法会在每个自由属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回他们
		console.log(Object.getOwnPropertyDescriptors(book));
		//返回结果如下，返回的是一个对象类型，包含数据属性和访问器属性
		//{year_: {…}, edition: {…}, year: {…}
		//edition: {value: 1, writable: false, enumerable: false, configurable: false}
		//year: {enumerable: false, configurable: false, get: ƒ, set: ƒ}
		//year_: {value: 2017, writable: false, enumerable: false, configurable: false}


		//合并对象
		//为合并对象提供了Object.assign()方法，该方法接受一个目标对象，和一个或多个源对象作为参数
		//，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true）和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象


		//简单的合并
		let source,result,target;
		target={};
		source={id:1};
		result=Object.assign(target,source);//将source里的属性复制给target
		console.log(target);
		console.log(result);//result返回的是修改后的目标对象

		//这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值
		let dest={},src={};
        dest = { 
				 set a(val) { 
				 console.log(`Invoked dest setter with param ${val}`); 
				 } 
				}; 

		src = { 
		 get a() { 
		 console.log('Invoked src getter'); 
		 return 'foo'; 
		 } 
		};
		//使用Object.assign方法时，该方法是将src的属性赋值给dest,本质上会调用src上的get()方法，所以会先打印出Invoked src getter,然后将返回值"foo",作为参数传递给dest,调用dest上的set方法来设置属性的值,此时foo作为参数传入，打印出Invoked dest setter with param foo,但是设置函数没有赋值操作，其实dest没有得到src的值，没有得到get()方法属性
		Object.assign(dest, src);
		console.log(dest);//{ set a(val) {...} }

		//覆盖属性：当使用合并的Object.assign()方法时，如果后面的源对象含有一样的值，则会使用最后的一个值，对之前的值进行覆盖
		let cover={id:2};
		Object.assign(cover,{id:1,color:'yellow',name:'es'},{id:111,color:'red',age:12});
		console.log(cover);

		//对象标识及相等判定
		//Object.is() 这个方法必须接收两个参数
		console.log(Object.is(true, 1)); // false 
		console.log(Object.is({}, {})); // false 
		console.log(Object.is("2", 2)); // false
		//要检查超过两个值，递归地利用相等性传递即可：

		function check(x, ...rest) { 
		 return Object.is(x, rest[0]) && 
		 (rest.length < 2 || check(...rest)); 
		}


		//增强的对象语法
		//属性值简写
		let name='mll';
		let obj={
			name//这一步的写法是name:name，因为属性名和变量名一致，可以省略，如果上下文中没有name属性会报错
		}
		console.log(obj);

		//会在不同作用域间保留属性名
		function make(name)
		{return{
			name//这一步的写法是：name:name，将函数形参的name属性赋给name
		}
		}
		let persons=make('xiaoming');//函数的返回值是一个对象类型，将该对象赋给persons,得到person={name:'xiaoming'}
		console.log(persons.name);

		//可计算属性
		const nameKey = 'name'; 
		const ageKey = 'age'; 
		const jobKey = 'job'; 
		let personm = { 
		 [nameKey]: 'mll', 
		 [ageKey]: 27, 
		 [jobKey]: 'es' 
		};
		console.log(personm);//中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值,

		//简写方法名
		let person3={
			sayname:function(name){
				console.log(name);
			}
		}
		person3.sayname('mll');
		//将上式简写
		let person4={
			sayname(name){
				console.log(name);
			}
		}
		person4.sayname('mll');


		//简写方法名对获取函数和设置函数也是适用的
		let saynames='sayName';
		let personf = { 
		 name_: '', 
		 get name() { 
		 return this.name_; 
		 }, 
		 set name(name) { 
		 this.name_ = name; 
		 }, 
		 //简写方法名与可计算属性可兼容
		 //sayName() { 
		 //会将[saynames]得到sayName
		 [saynames](){
		 console.log(`My name is ${this.name_}`); 
		 } 
		};
		personf.name = 'Matt'; 
		personf.sayName(); // My name is Matt


		//对象解构
		let person5={
			name:'mll',
			age:22
		}
		let {name:personname,age:personage}=person5;
		console.log(personname);
		console.log(personage);

		//可以简写为，将变量名简写为属性名
		let person6={
			color:'yellow',
			job:'es'
		}
		//这句的完整形式·是{color:color,job:job},第二个color,job都是变量，为属性值简写
		let {color,job}=person6;
		console.log(color);
		console.log(job);
		//对于对象中不存在的值，打印出来是undefinend;
		let person7={
			colors:'red',
			job:'es'
		}
		//let {colors,age}=person7;
		let {colors,age=22}=person7;//可以解构赋值的同时赋给默认值
		console.log(colors);
		console.log(age);
		//console.log(age);//undefinend

		//嵌套解构
		let person8={
			name:"xiaoming",
			age:23,
			title:{
				book:'es'
			}
		}
		let personcopy={};
		({name:personcopy.name,age:personcopy.age,title:personcopy.title}=person8);
		console.log(personcopy);
		person8.title.book='前端';//修改person8的值，personcopy的值也会发生变化
		console.log(personcopy);

		//
		let person9={
			job:{
				title:'es'
			}
		}
		let personcopys={};
		({job:personcopys.job}=person9);
		console.log(personcopys);
		///let personcopyss={};
		//({job:{title:personcopyss.job.title}}=person9);//外层属性没有定义的情况下不能使用嵌套赋值，title is undefinend
		//console.log(personcopyss);


		

	</script>

</body>
</html>